---
knit: 
  bookdown::render_book:
    output_dir: ""
output: CTUtemplate::report_pdf
toc: true
lot: false
lof: false
params:
  author: "FirstName LastName"
  email: "FirstName.LastName@ctu.unibe.ch"
  job: "Senior Statistician"
  projnum: 1234
  projname: "Project X"
  version: "xx"
  reportname: "Examples"
  dir: "{{dir}}"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r clo_chunk, eval = FALSE, echo = FALSE}
# The Latex template requires a CLO file. This chunk (clo_chunk), together with 
#   the params above, can create it.
#   click the 'run all chunks above' button on the right hand side of clo_chunk 
#   (this loads the params from the YAML header), then run clo_chunk with the 
#   arrow pointing to the right.
# You need to do this before compiling for the first time and any time that one 
#   of the params mentioned below changes
CTUtemplate::use_ubreportclo(
  # THE SAME DIR AS THE Rmd FILE
  dir = params$dir, 
  # Personal info
  sign = params$author,
  email = params$email,
  job = params$job,
  # Project info
  projnum = params$projnum,
  projname = params$projname,
  # Report info
  version = params$version,
  reporttype = params$reportname
)
# 'ordinary' Rmd files would have this specified in the yaml header, but that 
#   doesnt work with the LaTeX template... hence, an additional file needs to be 
#   defined.
```

\chapter{Latex syntax can be used}

A chapter is created like this...

```{r, eval = FALSE}
\chapter{Latex syntax can be used}
```



It is in fact the easiest (only?) way to get chapters...

Otherwise, document sections, subsections etc can be created using Rmd syntax

```{r, eval = FALSE}
# section
## subsection
### subsubsection
```

# section

## subsection

### subsubsection

# Unnumbered Sections {-}

Use '{-}' to signify that a section should not be numbered.

For chapters, place an asterisk after 'chapter' to use an unnumbered chapter.

```{r, eval = FALSE}
\chapter*{Latex syntax can be used}
```


\chapter{Tables}

Tables can be created via multiple approaches. Short tables that can be edited by hand can be written in Markdown

```{r, eval = FALSE}

| Tables        | Are           | Cool  |
| ------------- |:-------------:| -----:|
| col 3 is      | right-aligned | $1600 |
| col 2 is      | centered      |   $12 |
| zebra stripes | are neat      |    $1 |

```

| Tables        | Are           | Cool  |
| ------------- |:-------------:| -----:|
| col 3 is      | right-aligned | $1600 |
| col 2 is      | centered      |   $12 |
| zebra stripes | are neat      |    $1 |


btabler is another option. Here, you should use 'results='asis'' in the chunk option

```{r, results='asis'}
# remotes::install_github("CTU-Bern/btabler")
library(btabler)
df <- data.frame(name = c("", "Row 1", "Row2"),
                 out_t = c("Total", "t1", "t1"),
                 out_1 = c("Group 1", "g11", "g12"), 
                 out_2 = c("Group 2", "g21", "g22"))
btable(df, nhead = 1, nfoot = 0, caption = "Table1")
```

other popular options are `xtable` and `knitr::kable`.

Flextable should also be possible to use (there seems to be some issue with the latex template - undefined control sequence...). Captions are/can be defined in the chunk header (see the [flextable site for more info](https://davidgohel.github.io/flextable/reference/knit_print.flextable.html)). Cell colours are, however, not supported.

```{r, tab.cap = "some caption text", eval=FALSE}
library(flextable)
flextable(head(mtcars))
```

# Referring to other locations

When compiled, Rmd files assume that any paths mentioned are relative to the location of the Rmd. In contrast, when running individual chunks, it paths relative to the current working directory. What that means is that if your working directory is `.` and your Rmd is stored in `./report` with data in `./data` and you use `data/file.csv` in your Rmd, it'll work fine when you run in interactive mode (one chunk at a time), but it will not compile when knit - then it'll be looking for `.report/data/file.csv`, which doesnt exist.

The solution is the `here` package. `here` contains the function `here` which is a drop in replacement for `file.path` with the difference that it always looks for a `.Rproj` file and uses that location as the reference point. `here::here("data", "file.csv")` will always point to the same location.


# One file or many files?

Markdown is great for literate programming. It can, however result in very lengthy documents, which doesn't make things easier to work with. One solution to this is to use child documents, which are secondary Rmd files, which should be included in the main document. Child Rmds do not need the YAML header. 

Were the following to be saved into a file (e.g. foo.Rmd), it could be included into this document via the `child` argument to an R chunk (e.g. uncomment the following code)

<!-- ```{r, child=foo.Rmd} -->
<!-- ``` -->


start `foo.Rmd`:

# foo

whatver prose you want

```{r}
# do stuff

```

end `foo.Rmd`

Another solution would be using normal R scripts, which can be sourced:

```{r, eval = FALSE}
source(here::here("rscript", "file.R"))
```

As mentioned in the previous section, the `here` package can be used to make paths that are robust to changes in the working directory.

# Landscape pages

Markdown itself doesnt seem to be able to be able to rotate pages, but Latex can. Surround the part that should be rotated with `\begin{landscape}` and `\end{landscape}`. 

\begin{landscape}
stuff that should be in landscape (probably tables...)
\end{landscape}

# R Markdown {-}

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

```{r cars}
summary(cars)
```

# Including Plots

You can also embed plots, for example:

```{r pressure, echo=FALSE}
plot(pressure)
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.
